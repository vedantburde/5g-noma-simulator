<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>5G NOMA Power Domain & SIC Simulator</title>
    <style>
        :root {
            --bg: #0f172a;
            --panel: rgba(30, 41, 59, 0.8);
            --text: #f8fafc;
            --user1: #ec4899; /* Pink */
            --user2: #06b6d4; /* Cyan */
            --combined: #8b5cf6; /* Purple */
            --border: #334155;
        }
        body {
            margin: 0; padding: 0;
            background-color: var(--bg);
            color: var(--text);
            font-family: 'Segoe UI', system-ui, sans-serif;
            display: flex; flex-direction: column; align-items: center;
            height: 100vh; overflow: hidden;
        }
        header {
            text-align: center; margin-top: 20px;
            text-transform: uppercase; letter-spacing: 2px;
        }
        h1 { margin: 0; color: var(--combined); font-size: 2rem; text-shadow: 0 0 10px rgba(139, 92, 246, 0.5); }
        .dashboard {
            display: flex; gap: 20px; margin-top: 20px; width: 90%; max-width: 1200px;
        }
        .controls {
            flex: 1; background: var(--panel); padding: 25px;
            border-radius: 16px; border: 1px solid var(--border);
            backdrop-filter: blur(10px); box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        .visualizer {
            flex: 2; background: var(--panel); padding: 20px;
            border-radius: 16px; border: 1px solid var(--border);
            display: flex; flex-direction: column; align-items: center;
        }
        canvas {
            background: #1e293b; border-radius: 8px; border: 1px solid var(--border);
            width: 100%; max-height: 400px; margin-top: 10px;
        }
        .slider-group { margin-bottom: 25px; }
        label { display: flex; justify-content: space-between; font-weight: bold; margin-bottom: 10px; }
        input[type="range"] { width: 100%; cursor: pointer; accent-color: var(--combined); }
        .user1-lbl { color: var(--user1); }
        .user2-lbl { color: var(--user2); }
        .btn {
            width: 100%; padding: 15px; border: none; border-radius: 8px;
            background: linear-gradient(135deg, #8b5cf6, #3b82f6);
            color: white; font-size: 1.1rem; font-weight: bold; cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            text-transform: uppercase; letter-spacing: 1px;
        }
        .btn:hover { transform: translateY(-2px); box-shadow: 0 5px 15px rgba(139, 92, 246, 0.4); }
        .status { margin-top: 20px; padding: 15px; border-radius: 8px; background: rgba(0,0,0,0.3); font-size: 0.95rem; line-height: 1.5; }
    </style>
</head>
<body>

    <header>
        <h1>NOMA Power-Domain Multiplexing</h1>
        <p>Successive Interference Cancellation (SIC) DSP Engine</p>
    </header>

    <div class="dashboard">
        <div class="controls">
            <div class="slider-group">
                <label class="user1-lbl">User 1 Distance (Cell Edge): <span id="u1-val">800m</span></label>
                <input type="range" id="u1-dist" min="500" max="1000" value="800">
            </div>
            <div class="slider-group">
                <label class="user2-lbl">User 2 Distance (Cell Center): <span id="u2-val">200m</span></label>
                <input type="range" id="u2-dist" min="50" max="400" value="200">
            </div>
            
            <button class="btn" id="sic-btn">Run SIC Decoding Algorithm</button>
            
            <div class="status" id="status-box">
                <b>System Idle:</b> Adjust distances to allocate power.<br>
                NOMA assigns higher power to the far user to overcome path loss, and superimposes both signals.
            </div>
        </div>

        <div class="visualizer">
            <h3 style="margin: 0; color: #cbd5e1;">Time-Domain Signal Oscilloscope</h3>
            <canvas id="scopeCanvas" width="800" height="400"></canvas>
        </div>
    </div>

    <script>
        // Interactive DSP Simulation - Code by Vedant
        const canvas = document.getElementById('scopeCanvas');
        const ctx = canvas.getContext('2d');
        const u1Slider = document.getElementById('u1-dist');
        const u2Slider = document.getElementById('u2-dist');
        const u1Val = document.getElementById('u1-val');
        const u2Val = document.getElementById('u2-val');
        const sicBtn = document.getElementById('sic-btn');
        const statusBox = document.getElementById('status-box');

        let timeOffset = 0;
        let animationId;
        let sicStage = 0; // 0: Normal, 1: Decode U1, 2: Subtract, 3: Decode U2

        // Waveform Parameters
        const freq1 = 0.02; // Low freq for User 1 data
        const freq2 = 0.08; // High freq for User 2 data

        function getPowerAllocation() {
            // Farther distance = worse channel = needs more power
            const d1 = parseInt(u1Slider.value);
            const d2 = parseInt(u2Slider.value);
            
            // Simplified path-loss inversion for NOMA power allocation
            const totalPower = 150; // Canvas amplitude max
            const p1Ratio = d1 / (d1 + d2);
            const p2Ratio = d2 / (d1 + d2);

            return { amp1: totalPower * p1Ratio, amp2: totalPower * p2Ratio };
        }

        function drawWave(amplitude, frequency, color, offset, label, phaseShift = 0) {
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            
            for (let x = 0; x < canvas.width; x++) {
                // Sine wave calculation
                const y = Math.sin(x * frequency + offset + phaseShift) * amplitude;
                if (x === 0) ctx.moveTo(x, canvas.height / 2 - y);
                else ctx.lineTo(x, canvas.height / 2 - y);
            }
            ctx.stroke();

            // Label
            ctx.fillStyle = color;
            ctx.font = '16px Arial';
            ctx.fillText(label, 20, canvas.height / 2 - amplitude - 10);
        }

        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw center line
            ctx.strokeStyle = '#334155'; ctx.lineWidth = 1;
            ctx.beginPath(); ctx.moveTo(0, canvas.height/2); ctx.lineTo(canvas.width, canvas.height/2); ctx.stroke();

            const { amp1, amp2 } = getPowerAllocation();

            if (sicStage === 0) {
                // Superimposed Signal
                ctx.beginPath();
                ctx.strokeStyle = '#8b5cf6';
                ctx.lineWidth = 4;
                for (let x = 0; x < canvas.width; x++) {
                    const y1 = Math.sin(x * freq1 + timeOffset) * amp1;
                    const y2 = Math.sin(x * freq2 + timeOffset) * amp2;
                    if (x === 0) ctx.moveTo(x, canvas.height / 2 - (y1 + y2));
                    else ctx.lineTo(x, canvas.height / 2 - (y1 + y2));
                }
                ctx.stroke();
                ctx.fillStyle = '#8b5cf6'; ctx.fillText('Superimposed Transmitted Signal', 20, 30);
            } 
            else if (sicStage === 1) {
                drawWave(amp1, freq1, '#ec4899', timeOffset, '1. Extracting High-Power Signal (User 1)');
            }
            else if (sicStage === 2) {
                 drawWave(amp1, freq1, 'rgba(236, 72, 153, 0.3)', timeOffset, '2. Subtracting User 1 Signal from Total (DSP)');
            }
            else if (sicStage === 3) {
                drawWave(amp2, freq2, '#06b6d4', timeOffset, '3. Recovered Low-Power Signal (User 2)');
            }

            timeOffset += 0.05;
            animationId = requestAnimationFrame(animate);
        }

        // Event Listeners
        u1Slider.addEventListener('input', (e) => { u1Val.innerText = e.target.value + 'm'; sicStage = 0; statusBox.innerHTML = "<b>System Idle:</b> Adjust distances to allocate power."; });
        u2Slider.addEventListener('input', (e) => { u2Val.innerText = e.target.value + 'm'; sicStage = 0; statusBox.innerHTML = "<b>System Idle:</b> Adjust distances to allocate power."; });

        sicBtn.addEventListener('click', () => {
            if (sicStage === 0) {
                sicStage = 1;
                statusBox.innerHTML = "<b>SIC Phase 1:</b> The receiver treats the weaker User 2 signal as noise and decodes the High-Power User 1 signal.";
                sicBtn.innerText = "Next: Subtract Interference";
            } else if (sicStage === 1) {
                sicStage = 2;
                statusBox.innerHTML = "<b>SIC Phase 2:</b> The decoded User 1 signal is re-modulated and subtracted from the total received wave.";
                sicBtn.innerText = "Next: Decode User 2";
            } else if (sicStage === 2) {
                sicStage = 3;
                statusBox.innerHTML = "<b>SIC Phase 3:</b> With User 1's interference removed, the receiver can cleanly decode the Low-Power User 2 signal.";
                sicBtn.innerText = "Reset Simulation";
            } else {
                sicStage = 0;
                statusBox.innerHTML = "<b>System Idle:</b> Adjust distances to allocate power.";
                sicBtn.innerText = "Run SIC Decoding Algorithm";
            }
        });

        // Start
        animate();
    </script>
</body>
</html>